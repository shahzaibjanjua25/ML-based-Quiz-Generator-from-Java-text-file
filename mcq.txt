Java
• 1991 - James Gosling, Sun Microsystems, Inc. 
• Originally a platform independent language for programming home appliances and was called “Oak” later renamed “Java” in 1995. 
• Later (1994) used for World Wide Web applications (since byte code can be downloaded and run without compiling it)
 • Eventually used as a general-purpose programming language (for the same reason as above plus it is object-oriented)
 • Why the name “Java”? Java was then named “Java”, paying homage to the large amounts of coffee consumed by the team. 
• Now owns by Oracle
• Full-fledged application programming language 
• Additional capability as a Web programming language (currently the strength of its application base) 
• A pure OO programming language 
• NOT radical or especially new 
• Adopts its looks from C++, and its behavior from Smalltalk 
• Compiled to processor-neutral instruction set then interpreted on each supporting platform
 • Extremely fast adoption rate! (Due to WWW)

Java Terminology
• Class - A collection of data and methods that operate on that data. 
• Method - A group of statements in a class that handle a task.
 • Attribute - A property of an instance of a class.
 • Interface - A skeleton class.
 • Package - A group of logically related codes (classes & interfaces).

• Bytecodes -  A set of instructions that look like machine code, but are not specific to any processor.
 • Virtual Machine - The environment in which Java runs. The JVM is responsible for executing the bytecodes and has responsibility for the fundamental capabilities of Java.

Comments
Comments provide information to the people who read the program 
• Comments are removed by the preprocessor, therefore the compiler ignores them • In Java, there are two types of comments • Single line comments // • Delimited comments /* */ for comments with more than one line.
• In Java is fully object oriented, even the simplest program needs to be written using a class. • HelloWorld is the name of the class. • A public class needs to be stored in a file name that matches the class name. i.e. The above code needs to be saved in a filename called HelloWorld.java

The main method
• Java programs begin executing at method main. The main method must be given as above. • The main method is one of the methods in a class • void methods do not return a value.
Output Statement
Instructs the computer to display the data within brackets to the screen. • “Hello World !” :String / String Literal. What you need to display on screen • System.out.println() moves the cursor to the next line after displaying the data

Java Development Environment
1.	Install the Java JDK. The latest Java SE JDK is 9. We will use Java SE JDK 8 in this course. 2. Editing a program • Type a Java program ( source code ) • e.g : vi editor ( Linux ) notepad ( Windows DOS prompt ) IDE (Eclipse, IntelliJ ) • Extension : .java
2.	Compiling a Java program • The java compiler (javac) compiles java code to an intermediate language called Java Byte Code. This is a platform neutral low level language which can be translated to machine code. Compiled java programs are stored in files with the extension .class 4. Running a Java Program • The java interpreter is used to run a compiled program on your computer. Each platform has its own Java Virtual Machine which translates Java Bytecode to machine code. 5.

Integrated Development Environments ( IDEs )
• Provides tools that support the software development process • Includes, editors for writing & editing programs, debuggers for locating logical errors, design tools etc…. • Eclipse • IntelliJ

Java’s magic Byte Code

• Generated by Java compiler ▪ Instead of generating machine language as most compilers do, the Java compiler generates byte code. • Easily translated to machine language of various kinds of computers • Executed by Java interpreter • Invisible to programmer 
• You don't have to Know anything about how byte code works to write a Java program.
Language Translation

A source program is the one that you write in the Java language and that always has a file extension of .java.
 
An object program is the binary byte-code program generated by the Java compiler, which always has a file extension of .class.

 The .class file generated by the Java compiler contains byte code which is a low-level code similar to machine language, but generic and not specific to any particular CPU.

Java Virtual Machine

A given computer must have its own Java interpreter as part of a Java Virtual Machine, or JVM, to translate the generic bytecode into machine language for that CPU. 

Virtual Machine (VM) interprets bytecodes into native machine language and runs it. Different VM exists for different computers, since bytecode does not correspond to a real machine

Why Use Byte Code?

Disadvantages: 
• Requires both compiler and interpreter 
• Slower program execution 

Advantages:
 • Portability 
▪ Very important 
▪ same program can run on computers of different types (useful with the Internet)

 • Small in size
 ▪ linking at runtime
 ▪ Easy to exchange over a network

Java Program Patterns

• Stand Alone Applications 
▪ Java programs which run in command console 
▪ Applications with GUI (awt/swing) 

• Web-based Java Applications 
▪ Applets 
• Dynamic and interactive programs that can run inside a web page displayed by a browser enabled for Java 
▪ Servlets 
• Programs that run inside request/response oriented servers
 ▪ Java Server Pages 
• An extension to the servlet architecture. Allow for the separation of the display of web content and the generation of that content

J…. confusion
• JVM (Java Virtual Machine) 
▪ JVM is a part of both the JDK and JRE that translates Java byte codes and executes them as native code on the client machine. 
• JRE (Java Runtime Environment) 
▪ it is the environment provided for the java programs to get executed. It contains a JVM, class libraries, and other supporting files. It does not contain any development tools such as compiler, debugger, etc. 
• JDK (Java Development Kit) 
▪ JDK contains tools needed to develop the Java programs (javac, java, javadoc, appletviewer,jdb, javap, rmic....),and a JRE to run the programs. 
• Java SDK (Java software development kit)
 ▪ SDK comprises a JDK and extra software, such as application servers, debuggers, and documentation. 
• Java SE 
▪ Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers (Same as SDK) 
• J2SE, J2ME, J2EE 
▪ Any Java edition from 1.2 to 1.5

Java vs C++ Language

• Java control structures are identical in syntax
 • selection – if, switch, 
• Repetition – while, do while, for 

• Within a method the major difference is the print commands and the input commands.

 • The basic data types integers and float are used in the same way. There is a separate data type in Java for string data called String. 

• Calculations are also identical.

 • There is a slight difference on how arrays are declared (i.e. similar to C++ dynamic arrays)




Object Oriented Programming

• Object oriented programming is a method of implementation in which programs are organized as cooperative collections of objects, each of which represents an instance of some class, and whose classes are all members of a hierarchy of classes united via inheritance relationships.

• Object Oriented Programming is a method of implementation in which programs are organized as a collection of objects which cooperate to solve a problem. 

• Allows to solve more complex problems easily

• A complex system is developed using smaller sub systems 

• Sub systems are independent units containing their own data and functions

• Can reuse these independent units to solve many different problems

Classes

• A class is the abstract definition of the data type. It includes the data elements that are part of the data type, and the operations which are defined on the data type. 

• It is an Entity which could be a thing, person or something that is imaginary

• An entity can be described by the data (Properties ) and its behavior ( methods ) 

Classes and Objects

• An Object is a specific instance of the data type (class) 

• A class is a blue print of an object.

• Objects are instances of classes, which we can use to store data and perform actions

 • We need to define a class including the properties and methods and then create as many objects which has the same structure of the class (House example )

Java vs C++

• All methods are implemented in the class definition in Java. 

• Each property, method needs a specific access modifier e.g. private, public, protected

 • In Java there is no semi colon at the end of the class
        • In Java you only have dynamic objects.
       • Since Java has an automatic garbage collector, you do not need to use a command line delete to remove objects from memory.
  • We use the dot operator instead of the -> operator to access methods in Java.

Private & Public
• The private part of the definition specifies the data members of a class 
• These are hidden from outside the class and can only be accessed though the operations defined for the class 
• The public part of the definition specifies the operations as function prototypes 
• These operations, or methods as they are called, can be accesses by the main program.

Methods and Properties
• In C++ properties are called data members, other popular names for properties are attributes, variables. 
• In C++ methods are called member functions, other popular names are operations, behaviors. These are really functions.

Abstraction
An abstraction denotes the essential characteristics of an object that distinguish it from all other kinds of objects and thus provide crisply defined conceptual boundaries, relative to perspective of the viewer.
• Abstraction is the process of removing characteristics from ‘something’ in order to reduce it to a set of essential characteristics that is needed for the particular system.

Encapsulation
• Encapsulation is the process of compartmentalizing the elements of an abstraction that constitute its structure and behavior; encapsulation serves to separate the contractual interface of an abstraction and its implementation.

• It is the process of grouping related attributes and methods together, giving a name to the unit and providing an interface for outsiders to communicate with the unit.

Information Hiding
• Hide certain information or implementation decision that are internal to the encapsulation structure ( class ) 
• The only way to access an object is through its public interface
 • Public – anyone can access / see it
 • Private – no one except the class can see/ use it

Constructor
• The constructor is used to initialize the object when it is declared.
 • The constructer does not return a value, and has no return type ( not even void ) 
• The constructors has the same name as the class. 
• There can be default constructers or constructors with parameters 
• When an object is declared the appropriate constructor is executed.

• Default Constructors - Can be used to initialized attributes to default values
• Overloaded Constructors ( Constructors with Parameters  - ) Can be used to assign values sent by the main program as arguments

Getters and Setters
• In general properties are declared as private preventing them from being accessed from outside the class. 
• Typically an attribute will have a getter (accessor) (A get method to return its value) and a setter (mutator) (A set method to set a value). 
• e.g. a property called length will have a getter defined as int getLength() and a setter defined as void setLength(). Both these methods will be declared as public methods.

Generalization/Inheritance
• Child class is a type of the parent class 
• Used to showcase reusable elements in the class diagram 
• Child classes “inherit” the attributes and methods defined in the parent class
C++ vs Java - Inheritance
Java has a simpler inheritance mechanism where base class is extended as public. 
C++ has multiple inheritance compared to Java’s Single Inheritance.
When you want to call a base class constructor C++ Requires to explicitly name the base class. In Java we use the super keyword to access the direct descendent class. 
However this implies that in Java you can’t directly call a class higher in the hierarchy e.g. the Grandfather class which is not in C++
All methods in Java are virtual by default. In C++ we need to explicitly define polymorphic methods.

Object Class
• A class hierarchy is similar to the taxonomy of animals that shows their ancestry. • There are many breeds of dogs. A well known fact is that the common origin of a dog is the Gray Wolf. • All Java classes are derived from a class called Object. This includes all the existing Java built in classes and the classes that you write. The methods and properties of the Object class is accessible to any Java class that you create.
Polymorphism
• Greek meaning “having multiple forms“ 
• Ability to assign a different meaning or usage to something in different contexts 
• Specifically, to allow an entity such as a variable, a function, or an object to have more than one form

The Primitive Types
• Java defines eight primitive types of data: byte, short, int, long, char, float, double, and boolean.
• Integers This group includes byte, short, int, and long, which are for whole-valued signed numbers.
 • Floating-point numbers This group includes float and double, which represent numbers with fractional precision. 
• Characters This group includes char, which represents symbols in a character set, like letters and numbers. 
• Boolean This group includes boolean, which is a special type for representing true/false values.
Type Conversion and Casting
• Auto Conversion happens in Java for Simple Data Types in situations • The two types are compatible. • The destination type is larger than the source type. • Manual Casting is required when the destination is smaller than the source type
One Dimensional Arrays
• Slightly different from C/C++ 
	Define Array 
	Allocate Memory

Objects and Memory
• Declaring Objects in Java is a two step process.
	First, you must declare a variable of the class type. This variable does not define an object. Instead, it is simply a variable that can refer to an object. 
	Second, you must use the new operator to dynamically allocates (that is, allocates at run time) memory for an object and returns a reference to it. This reference is, more or less, the address in memory of the object allocated by new. 
	This reference is then stored in the variable. Thus, in Java, all class objects must be dynamically allocated.

Static Members
• Attributes and methods (members of a class) can be defined as static. 
• Static members do not belongs to an individual object.
 • Static members are common to all the instances (objects of the same class). 
• Static members are stores in static memory (a common memory location which can by everybody )

Static Modifiers
• The static modifier indicates that the attributes and methods are common to all the object in the whole class rather than to an individual object. 
• A static method does not operate on an object:
 • ClassName.methodName(parameterList) 
• Many attributes and methods we use are static:

Understanding Static
• There will be times when you will want to define a class member that will be used independently of any object of that class.
 • When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object.
 • You can declare both methods and variables to be static.
 • The most common example of a static member is main( ). main( ) is declared as static because it must be called before any objects exist.
• Instance variables declared as static are, essentially, global variables. When objects of its class are declared, no copy of a static variable is made. Instead, all instances of the class share the same static variable. 
• Methods declared as static have several restrictions:
	They can only directly call other static methods.
	They can only directly access static data. 
	They cannot refer to this or super in any way.

final properties
• Final is used to declare constants. 
• These can be declared as above in the class or initialized in the constructor.
 • A static final variable is a global constant.

Overloading
• Overloading occurs when there are methods with different signatures.
• Overriding occurs in inheritance when a descendant class replaces a method with the same signature.

Abstract Classes
• Used in situations in which you will want to define a superclass where some methods don’t have a complete implementation.
 • Here we are expecting the sub classes will implement these abstract methods. 
• One way this situation can occur is when a superclass is unable to create a meaningful implementation for a method. e.g an area() method of a Shape class.
• getArea() method will have different implementations depending on the child class. 
• Class Shape behave as a super class. 
• Any shape has an area. So that class Shape can contain a method called getArea(). 
• But implementing getArea() method is possible only when we know the child class. 
• The implementation of getArea() method is different from one child class to another
• The methods which cannot be implemented MUST be defined as abstract.
 • An abstract method does not have a method implementation (not even { }). 
• We cannot invoke (call) an abstract method. 
• The class which contain at least one abstract method MUST be defined as abstract.
• Every child class MUST override all the abstract methods of the parent class.
 • If a child class did not override all the abstract method of the parent, then the child class also become abstract
• A class which contain at least one abstract method must be defined as abstract.
 • Cannot create instances (object) from an abstract class. • All the child classes must override abstract methods of the parent. 
• Force the child class to contain methods defined by the parent class. 
• Their purpose is to behave as parent (base) classes. 
• Abstract classes are very generic 
• Usually a class hierarchy is headed by an abstract class 
• Classes from which objects can be instantiated - concrete 
• The ability to create abstract methods is powerful – each new class that inherits is forced to override these methods. ex. Mouse clicks and drags

Interfaces
• Is a contract between a class and the outside world. 
• When a class implements an interface it promises to provide the behavior in the interface (Implement the methods specified in the interface). 
• Interfaces can also store constants. These are essentially public static final variables.
• Interfaces are designed to support dynamic method resolution at run time. 
• it is possible for classes that are unrelated in terms of the class hierarchy to implement the same interface. This is where the real power of interfaces is realized.
Abstract classes vs Interfaces
• Use an abstract class if
	You want to share the code.
	Expect to have common methods or properties 
	You want to have access modifiers other than public 
	You want to have properties which not static or not final
• Use an interface if
	You want unrelated classes to implement the interfaces. 
	Want to take advantages of multiple inheritances

Data access control
• Member access modifiers – control access to class members through the keywords public, protected , default (friendly, no specifier) and private 
• public – members declared as public are accessible from anywhere in the program when the object is referenced. • protected – subclasses can access protected method/data from the parent class. 
• Default – such a class, method, or field can be accessed by a class inside the same package only. 
• private – members declared as private are accessible ONLY to methods of the class in which they are defined. All private data are always accessible through the methods of their own class. 
• USUALLY: data (instance variables) are declared private, methods are declared public.
 • NOTE: using public data is uncommon and dangerous practice

Java Packages
• Packages are containers for classes. They are used to keep the class name space compartmentalized. 
• For example, a package allows you to create a class named List, which you can store in your own package without concern that it will collide with some other class named List stored elsewhere. 
• Packages are stored in a hierarchical manner and are explicitly imported into new class definitions.
• The Java Package name consists of words separated by periods. The first part of the name represents the organization which created the package. The remaining words of the Java Package name reflect the contents of the package. The Java Package name also reflects its directory structure.

Default Packages
• If a class is in the same package as the class that uses it, it does not need import statement.
 • Default package - all the complied classes in the current directory. If a package is not specified, the class is placed in the default package.



Errors and Exceptions
Introduction
Rarely does a program run successfully at its very first attempt. It is common to make mistakes while developing as well as typing a program. A mistake might lead to an error causing the program to produce unexpected results. Errors are the wrongs that can make a program go wrong. 
An error may produce an incorrect output or may terminate the execution of the program abruptly or even may cause the system to crash. It is therefore important to detect and manage properly all the possible error conditions in the program so that the program will not terminate or crash during execution.

Types of Errors
Errors may broadly be classified into two categories:
 ❑ Compile-time errors 
❑ Run-time errors

Compile - Time Errors 
All syntax errors will be detected and displayed by the Java compiler and therefore these errors are known as compile time errors. Whenever the compiler displays an error, it will not create the .class file. It is therefore necessary that we fix all the errors before we can successfully compile and run the program.

Most of the compile-time errors are due to typing mistakes. The most common problems are:
❑ Missing semicolons
 ❑ Missing (or mismatch of) brackets in classes and methods 
❑ Misspelling of identifiers and keywords Missing double quotes in strings 
❑ Use of undeclared variables 
❑ Incompatible types in assignments, initializations. 
❑ Bad references to objects 
❑ Use of = in place of = = operator

Other errors we may encounter are related to directory paths. An error such as
 javac: command not found 
means that we have not set the path correctly. We must ensure that the path includes the directory where the Java executables are stored. Sometimes, a program may compile successfully creating the .class file but may not run properly. Such programs may produce wrong results due to wrong logic or may terminate due to errors such as stack overflow

Most common run-time errors are:
❑ Dividing an integer by zero 
❑ Accessing an element that is out of the bounds of an array
 ❑ Trying to store a value into an array of an incompatible class or type 
❑ Trying to cast an instance of a class to one of its subclasses 
❑ passing a parameter that is not in a valid range or value for a method 
❑ Trying to illegally change the state of a thread 
❑ Attempting to use a negative size for an array
 ❑ Using a null object reference as a legitimate object reference to access a method or a variable
 ❑ Converting invalid string to a number 
❑ Accessing a character that is out of bounds of a string

Program is syntactically correct and therefore does not cause any problem during compilation. However, while executing, it displays the following message and stops without executing further statements. 
When Java run-time tries to execute a division by zero, it generates an error condition, which causes the program to stop after displaying an appropriate message.

What is an Exception?
An exception is an abnormal event that arises during the execution (run time) of the program and disrupts the normal flow of the program. Java classifies exceptions as
 ❑ Errors 
❑ Exceptions 
▪ Checked Exceptions
 ▪ Unchecked Exceptions
Error Class
❑ An Error is a subclass of Throwable that indicates serious problems. 
❑ Errors represent critical errors, once occurs the system is not expected to recover from (irrecoverable). 
❑ Errors can be generated from mistake in program logic or design. 
❑ Most applications should not try to handle it. 
e.g. OutOfMemoryError, VirtualMachineError, AssertionError

Exception Class
This class represents the exceptional conditions that user must handle or catch.
 ❑ A Java exception is an object that describes an exceptional (that is, error) condition that has occurred in a piece of code. When an exceptional condition arises, an object representing that exception is created and thrown in the method that caused the error. 
❑ That method may choose to handle the exception itself, or pass it on. Either way, at some point, the exception is caught and processed. 
❑ Exceptions can be generated by the Java run-time system, or they can be manually generated by your code.

Checked Exceptions
❑ Checked Exception in Java is all those Exception which requires being catches and handled during compile time. 
❑ The classes that extend Throwable class except RuntimeException and Error are known as checked exceptions
e.g.IOException, SQLException etc. Checked

Unchecked Exceptions 
❑ Unchecked exceptions are usually caused by incorrect program code or logic such as invalid parameters passed to a method.
 ❑ The classes that extend RuntimeException are known as unchecked exceptions. 
❑ Unchecked exceptions are checked at runtime. 
e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException
Exception Handling
There are two ways to handle Exceptions:
 ❑ Throw out and ignore
 When an Exception occur inside a code of program simply throw it out and ignore that an Exception occur declare the methods as throws Exception. 
❑ Catch and handle
 If a code segment is generating an Exception place it inside a try block. Then mention the way to handle the Exception inside a catch block use try-catch blocks

Exception Handling Using try and catch
1. Find the problem (Hit the exception). 
2. Inform that an error has occurred (Throw the exception)
 3. Receive the error information (Catch the exception) 
4. Take corrective actions (Handle the exception)
 Provides two benefits
. ▪ Allows you to fix the error
. ▪ Prevents the program from automatically terminating.

❑ To guard against and handle a run-time error, simply enclose the code that you want to monitor inside a try block. 
❑ Immediately following the try block, include a catch clause that specifies the exception type that you wish to catch.

Multiple catch clauses
❑ More than one exception could be raised by a single piece of code.
 ❑ To handle this type of situation, programmer can specify two or more catch clauses, each catching a different type of exception. 
❑ When an exception is thrown, each catch statement is inspected in order, and the first one whose type matches that of the exception is executed. 
❑ After one catch statement executes, the others are bypassed, and execution continues after the try /catch block.
Catching More Than One Type of Exception with One Exception Handler
❑ In Java SE 7 and later, a single catch block can handle more than one type of exception. This feature can reduce code duplication and lessen the temptation to catch an overly broad exception. 
❑ In the catch clause, specify the types of exceptions that block can handle, and separate each exception type with a vertical bar (|):

Nested try Statements
❑ When a try catch block is present inside another try block then it is called the nested try catch block. 
❑ Each time a try block does not have a catch handler for a particular exception, then the catch blocks of parent try block are inspected for that exception, if match is found that that catch block executes. 
❑ If neither catch block nor parent catch block handles exception then the system generated message would be shown for the exception, similar to what we see when we don’t handle exception.


Finally Block
❑ finally statement that can be used to handle an exception that is not caught by any of the previous catch statements. 
❑ finally block can be used to handle any exception generated within a try block. It may be added immediately after the try block or after the last catch block shown as follows
 ❑ When a finally block is defined, this is guaranteed to execute, regardless of whether or not an exception is thrown. As a result, we can use it to perform certain house-keep

Exception Handling Using throws
❑ When an Exception occur inside a code of program simply throw it out and ignore. 
❑ Throws keyword is used for handling checked exceptions. By using throws we can declare multiple exceptions in one go. 
❑ A throws clause lists the types of exceptions that a method might throw.




Creating Your Own Exception Subclasses
❑ To define your own exception create a subclass of Exception (which is a subclass of Throwable).
❑ The Exception class does not define any methods of its own. It inherits those methods provided by Throwable. Thus, all exceptions, including those that you create, have the methods defined by Throwable available to them.

❑ Exception class defines four public constructors. Two are shown here: 
❖ Exception( ) 
❖ Exception(String msg) 
The first form creates an exception that has no description. The second form lets you specify a description of the exception.

Strings in Java
• String is a sequence of characters 
• Java implements strings as objects (created by class String) 
• String, StringBuffer and StringBuilder classes are defined in java.lang package. Thus, are available to a program automatically
 • All String, StringBuffer and StringBuilder classes are final
 • String objects are immutable
 • StringBuffer and StringBuilder objects are mutable

Creation of String Literals
• Each time you create a string literal, the JVM checks the string constant pool first
 • If the string already exists in the pool, a reference to the pooled instance is returned
 • If string doesn't exist in the pool, a new string instance is created and placed in the pool

equals () versus ==
• Both equals() and == operator performs different operations
 • equals() is a method that compares the characters in a string object
 • == is an operator that compares two object references to see whether they refer to the same instance


Strings in Java are Immutable
• Strings are immutable. That is, once a String is constructed, its contents cannot be modified
 • However, the variable declared as String reference can be changed to point at some other String instance 
• It is not efficient to use String if you need to modify your string frequently (that would create many new Strings occupying new storage areas)

StringBuffer & StringBuilder
• As strings are immutable, Java provides two other classes to support mutable strings:
 • StringBuffer 
• StringBuilder 

*both classes in java.lang package 
• A StringBuffer or StringBuilder object is just like any ordinary object, which are stored in the heap and not shared, and therefore, can be modified without causing adverse side-effect to other objects

StringBuilder
• Introduced in JDK5
 • StringBuilder is similar to StringBuffer except for one difference that it is not synchronized (not thread-safe) 
*In cases in which a mutable string is accessed by multiple threads, and no external synchronization is employed, you must use StringBuffer rather than StringBuilder

Java Collection Framework

Collections in Java
The Collections Framework is a sophisticated hierarchy of interfaces and classes that provide state-of-art technology for managing groups of objects
The primary advantages of a collections framework are;
 ❑ Reduces programming effort 
❑ Increases performance 
❑ Provides interoperability between unrelated APIs
 ❑ reduces the effort required to learn APIs
 ❑ Reduces the effort required to design and implement APIs
 ❑ Fosters software reuse 
Generics make Collections type safe. Before generics, collections stored Object references; can store any type of object. Thus avoids run-time mismatch errors.

Collection Interface
• Collection is the foundation upon which the Collection Framework is built on. 
• Declaration: 
	Interface Collection
	E: specifies the type of objects that collection will hold 
List Interface
❑ Java.util.List is a child interface of Collection. 
❑ List is an ordered collection of objects in which duplicate values can be stored. Since List preserves the insertion order it allows positional access and insertion of elements. 
❑ List Interface is implemented by ArrayList, LinkedList, Vector and Stack classes.

Queue Interface
❑ The java.util.Queue is a subtype of java.util.Collection interface. 
❑ It is an ordered list of objects with its use limited to inserting elements at the end of list and deleting elements from the start of list. It follows First In First Out (FIFO) principle.

Set Interface 
 ❑ The java.util.Set interface is a subtype of Collection interface. 
❑ A Set is a Collection that cannot contain duplicate elements. It models the mathematical set abstraction.
 ❑ Set interface is implemented by SortedSet interface and Hashset and LinkedHashSet classes. 
❑ SortedSet interface declares the behavior of a set sorted in ascending order. TreeSet class implements this interface.
ArrayList Class 
❑ ArrayList class extends the AbstractList class and implements the List interface. 
❑ ArrayList support dynamic arrays (can increase and decrease size dynamically).
❑ Elements can be inserted at or deleted from a particular position
❑ ArrayList class has many methods to manipulate the stored objects 
❑ If generics are not used, ArrayList can hold any type of objects.

Obtaining Array from an ArrayList 
Reasons for converting array to an ArrayList 
❑ To obtain faster processing time for certain operations
 ❑ To pass an array to a method that is not overloaded to accept a collection 
❑ To integrated collection-based code with legacy code that don’t understand collections

Stack Class 
• Stack is a subclass of Vector 
• Stacks are dynamic data structures that follow the Last In First Out (LIFO) principle

Queue Interface
 • The Queue interface extends Collection 
• Defines queue data structure which is normally First-In-First-Out 
• Elements are added from one end and elements are deleted from another end 
• Most common classes are the PriorityQueue and LinkedList in Java 
• In Priority Queue, elements are removed from one end, but elements are added according to the order defined by the supplied comparator
Set Interface 
• The java.util.Set interface is a subtype of Collection interface.
 • A Set is a Collection that cannot contain duplicate elements. It models the mathematical set abstraction. 
• Set interface is implemented by SortedSet interface and Hashset and LinkedHashSet classes. 
• SortedSet interface declares the behavior of a set sorted in ascending order.
 • TreeSet class implements this interface and TreeSet class are stored in ascending order. 
• HashSet class stores the elements by using a mechanism called hashing and contains unique elements only

HashSet Class 
• HashSet extends AbstractSet and implements the Set interface.
 • It creates a collection that uses a hash table for storage. 
• No duplication and unordered 
• In hashing, the informational content of a key is used to determine a unique value, called its hash code. The hash code is then used as the index at which the data associated with the key is stored. The transformation of the key into its hash code is performed automatically

TreeSet Class 
• TreeSet extends AbstractSet and implements the NavigableSet interface
 • Objects are stored in sorted, ascending order

 Maps 
❑ A map is an object that stores associations between keys and values, or key/value pairs. Given a key, you can find its value. 
❑ Both keys and values are objects. The keys must be unique, but the values may be duplicated. 
❑ Some maps can accept a null key and null values, others cannot. 
❑ Map is useful if you have to search, update or delete elements on the basis of key
 ❑ Maps are not part of the Collections Framework

HashMap Class 
 ❑ The HashMap class extends AbstractMap and implements the Map interface. It uses a hash table to store the map.
 ❑ HashMap is a generic class that has this declaration: class HashMap K specifies the type of keys, and V specifies the type of values
Hashmap 
• Values in hash map are not ordered or not sorted 
• Remove duplicates in the key

LinkedHashMap 
• HashMap with additional feature that it maintains insertion order
 • contains values based on the key
 • Remove duplicates in the key
 • When Display, the order is not guaranteed

TreeMap
 • contains values based on the key 
• contains only unique elements
 • maintains ascending orders 
• provides an efficient means of storing key-value pairs in sorted order

Generics
Wrapper class / Covering class 
• Wrapper class in java provides the mechanism to convert primitive datatype into object and object into primitive type. 
• For each primitive datatype, there exists a covering class in the java.lang package.
 byte → Byte 
short → Short
 int → Integer 
long → Long float → Float 
double → Double 
char → Character
 Boolean→ Boolean
• The automatic conversion of primitive type into object is known as autoboxing and vice-versa unboxing. 
• Since J2SE 5.0, autoboxing and unboxing feature converts primitive into object and object into primitive automatically.

Generics in Java 
• Concept of “generics” was introduced in JDK 5 to deal with type-safe objects. 
• Introduction of generics has changed Java in 2 ways: 
	Added new syntax to Java language 
	Caused changes to many of the classes & methods in the core API 
• With the use of generics, it is possible to create classes, interfaces & methods which works in typesafe manner.
• “Generics” means “parameterized types”. 
• Many algorithms are same regardless of its data type that is applied. With generics, you can define the algorithm once independently of any specific type of data. Later, you can use the algorithm to a wide variety of data types without any additional effort.

Advantages of Generics 
1. Type-safety : We can hold only a single type of objects in generics. It doesn’t allow to store other types of objects. 
2. Type casting is not required: There is no need to typecast the object. All type conversions are implicit. 
3. Compile-Time Checking: It is checked at compile time so problem will not occur at runtime. The good programming strategy says it is far better to handle the problem at compile time than at runtime.

Implementation 
• When you are in need to store a list of values, you shall use an array.
Collection value = new ArrayList();
 • This statement allows you to create a list of elements (list of marks). 
• Note that Collection is an interface and cannot be instantiated directly.
 • ArrayList is a class which implements the Interface List which extends the Interface Collection


Type Parameters 
The type parameter naming conventions are as follows: 
T - Type  E – Element  K - Key  N – Number  V – Value

Bounded Type Parameters
 • There may be times when you will want to restrict the kind of data types that are allowed to be passed to a type parameter. 
e.g.: A method that operates on numbers might only want to accept instances of Number or its subclasses. 
• To declare a bounded type parameter, list the type parameter's name, followed by the extends keyword, followed by its upper bound in the following format. 
• Note: T, can only be replaced by the superclass or its subclasses.

Bounded Type Parameters cont. 
• In addition to using a class type as a bound, you can also use an interface type too! In fact, you can specify multiple interfaces as bounds. 
• A bound can include a class type & one or more interfaces. In this case, the class type needs to be specified first. 
• When a bound include an interface type, only type arguments that implement that interface are legal. 
• When specifying a bound that has a class & an interface or multiple interfaces, use the & operator to connect them

Limitations in Generics 
• Type parameters cannot be instantiated - It is not possible to create instances of a type parameter
 • Restriction on static members - No static member can use a type parameter declared by the enclosing class. Note that you can declare static generic methods. 
• Generic array restriction – 
	Cannot instantiate an array whose element type is a type parameter. 
	Cannot create an array of type specific references 
• Generic exception restriction - A generic class cannot extend Throwable. This means we cannot create generic exception classes.

Thread Vs. Process 

	Threads are easier to create than processes since they don't require a separate address space. 
	Threads are considered lightweight because they use far less resources than processes. 
	Processes are typically independent, while threads exist as subsets of a process 
	Processes have separate address spaces, whereas threads share their address space 
	Context switching between threads in the same process is typically faster than context switching between processes
	A Thread in execution works with 
•	 thread ID 
•	 Registers (program counter and working register set) 
•	Stack (for procedure call parameters, local variables etc.) 

	A thread shares with other threads a process’s (to which it belongs to)

•	 Code section 

•	 Data section (static + heap)

•	  Permissions 

•	 Other resources (e.g. files)

Thread Yield method 

• Yield() is used to give the other threads of the same priority a chance to execute 
• This causes current running thread to move to runnable state. [running state to ready state]

Thread wait and notify
	Once thread executes wait() method it releases the lock and state changed from Runnable to waiting state.
	Other thread can acquire the lock and continue execution. 
	Once notify() method get executed the waited thread move to ready state and resume its execution. 
	notifyAll() This wakes up all the threads that called wait() on the same object


Daemon Threads
•	Daemon Threads are “backgroung threads”. 
	That provides service to other threads, e.g. The garbage collection thread.

•	The Java VM will not exit if non-daemon threads are executing 
•	The Java VM will exit if only Daemon threads are executing 
•	Daemon thread die when the Java VM exits

Design patterns

	Creational: involve object initialization and provide a way to decouple client from the object it needs to instantiate.

	Structural: lets you compose classes or objects into lager structures

	Behavioral: Concerned with how classes and objects interact or distribute responsibility 

Simple Factory Vs. factory Method

Simple Factory
Does not let you vary the product implementations being created.

Factory Method
Creates a framework that lets the sub classes decides which product implementation will be used.

Abstract Factory Pattern
Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

Command Pattern
Command declares an interface for all commands, providing a simple execute() method which asks the Receiver of the command to carry out an operation. (Order) 
• The Receiver has the knowledge of what to do to carry out the request.(Cheff)
• The Invoker holds a command and can get the Command to execute a request by calling the execute method.(Waiter) 
• The Client creates ConcreteCommands and sets a Receiver for the command. 
• The ConcreteCommand defines a binding between the action and the receiver. 
• When the Invoker calls execute the ConcreteCommand will run one or more actions on the Receive

Bridge Pattern
The Bridge pattern, which allows you to vary both the implementation and the abstraction by placing both in separate class hierarchies.

Template pattern
The Template method
 is the method, which serves as a template for an algorithm. 
 In the template,
	Each step of the algorithm is represented by a method (these are called as “hooks”)
	Some methods are handled by this class.
	Some methods are handled by the sub classes.
	The methods that need to be supplied by a subclass are declared abstract.
 
Template method pattern
The Template method defines the steps of an algorithm and follows subclasses to provide the implementation for one more steps.
 





 
 

 












